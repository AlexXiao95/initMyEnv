#!/bin/bash

# double click x11
function dcc {
    /usr/bin/env osascript <<-EOF
    tell application "XQuartz"
        reopen
        activate
    end tell

    tell application "System Events" to keystroke "," using {command down}
    tell application "System Events" to keystroke "  "
    tell application "System Events" to keystroke "w" using {command down}

    delay 0.3
    tell application "Terminal"
        reopen
        activate
    end tell
EOF
}

# about VPN connecting
function vpnconnect {
    randomIP4VPN
    /usr/bin/env osascript <<-EOF
    tell application "System Events"
            tell current location of network preferences
                    set VPN to service "VPN (L2TP)"
                    if exists VPN then connect VPN
                    repeat while (current configuration of VPN is not connected)
                        delay 1
                    end repeat
            end tell
    end tell
EOF
}

function vpndisconnect {
    /usr/bin/env osascript <<-EOF
    tell application "System Events"
            tell current location of network preferences
                    set VPN to service "VPN (L2TP)"
                    if exists VPN then disconnect VPN
            end tell
    end tell
    return
EOF
}

function randomIP4VPN {
    vpnfile="vpn.list"
    common="/Users/Hans/.vpnSetting/"
    gshuf ${common}/${vpnfile} | head -1 > ${common}/.listtmp

    ## backup the first version of preference list
    if [ ! -f ${common}/preferences.plist ]; then
        cp /Library/Preferences/SystemConfiguration/preferences.plist ${common}/
    fi

    shuf_vpn_server=$(cat ${common}/.listtmp)
    sudo sed -i "214s@g>.\{0,100\}<@g>${shuf_vpn_server}<@" /Library/Preferences/SystemConfiguration/preferences.plist

    rm ${common}/.listtmp
}

# change name for shell tab
function nn {
  if [ -z "$1" ]; then
    title=${PWD##*/} # current directory
  else
    title=$1 # first param
  fi
  echo -n -e "\033]0;$title\007"
}

# generate a backup
function backup
{
    if [ ! -z "$1" ] && [ "$1" == "-clean" ]; then
        if [ -f ~/.backup.logs ]; then
            rm ~/.backup.logs
        fi
    elif [ ! -z "$1" ] && [ -e "$1" ]; then
        current_time=$(date +%Y%m%d)_$(date +%T)
        absolute_path=$(realpath "$1")
        file_name=$(basename "${absolute_path}")
        file_path=$(dirname "${absolute_path}")
        touch "${file_path}/.tmp" > /dev/null
        if [ -f "${file_path}/.tmp" ]; then
            rm "${file_path}/.tmp"
            cp -r "$1" "${file_path}/${file_name}_${current_time}"
            chmod a-w "${file_path}/${file_name}_${current_time}"
            if [ -f "$1" ]; then
                md5=$(md5sum "$1" | awk '{print $1}')
            else
                md5="Direction"
            fi
            if [ ! -z "$2" ]; then
                exp="$2"
            else
                exp="No explain. "
            fi
            echo -e "${file_name}\t${current_time}\t${file_path}\t${md5}\t${exp}" >> ~/.backup.logs
            backup_file_dir="${file_path}/${file_name}_${current_time}"
            echo "------" >> ~/.backup.logs
            echo -e "${green}[FINISHED]${endcolor} ${file_path}/${file_name}_${current_time}"
        else
            echo -e "${red}[ERROR]${endcolor} permission denied! "
        fi
    else
        echo -e "${red}[ERROR]${endcolor} file not exists! "
    fi
}

# redifine use subl
if [ "$(uname)" == "Darwin" ]; then
    function subl
    {
        /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl "$1"
    }
fi

# redefine pushd and popd
function pushdd
{
    pushd "$1" > /dev/null
}
function popdd
{
    popd > /dev/null
}

# git regenerate origin
function gitregenerate
{
    if [ ! -d .git ]; then
        echo "No git repo found.."
        return
    fi
    if [ ! -f .git/FETCH_HEAD ]; then
        echo "Please fetch or pull first.."
        return
    fi

    if [[ $1 = "-a" ]]; then
        git_rege_name=${2:-"#GITNAME#"}
        git_rege_password=${3:-"#GITPASSWD#"}
    else
        read -rp "git name: " git_rege_name
        read -rsp "git passwd: " git_rege_password
        echo -ne "\n"
    fi

    repo_web=$(awk '{print $NF}' .git/FETCH_HEAD)
    git remote rm origin
    new_web=$(echo "${repo_web}" | sed "s@https://@https://${git_rege_name}:${git_rege_password}\@@")
    echo "${new_web}"
    git remote add origin "${new_web}"
}

# sedding
function sedding
{
    while read data; do
        echo "${data}" | sed "s@ @\\\ @g;s@\\\$@\\\\\$@g;s@'@\\\\\'@g;s@\"@\\\\\"@g;s@(@\\\(@g;s@)@\\\)@"
    done
}

# delete enter
function de
{
    while read data; do
        tmp=$(echo -n "${data}" | sed "s@\\\$@\\\\\$@g;s@\"@\\\\\"@g")
        echo -n "\"${tmp}\"" | pbcopy
    done
}

# sync
function get_pub_name
{
    echo "$1" | sed "s@ @\%20@g"
}

function websync
{
    #web="hanxiao.xin"
    #ip="106.14.7.228"
    web="108.61.247.112"
    ip="108.61.247.112"
    user="root"
    root_dir="/root/01_Project/03_offline-download"
    tool_dir="${root_dir}/02_tools"
    file_dir="${root_dir}/01_files"
    public="public"

    # cp dir directly
    if [ "$1" = "-d" ]; then
        if [ ! -e "$2" ]; then
            echo "file not exists!" 1>&2
        else
            realname=$(basename "$2")
            get_pub_name "${web}/${public}/${realname}" | pbcopy
            read -rp "Set Valid Time: " valid_time
            scp -r "${realname}" ${user}@${ip}:${file_dir}
            ssh ${user}@${ip} "${tool_dir}/websync.sh \"${realname}\" \"${valid_time}\""
            get_pub_name "${web}/${public}/${realname}"
        fi

    elif [ "$1" = "-c" ]; then
        ssh ${user}@${ip} "${tool_dir}/websync.sh -c1"
        read -rp "Are you sure to delete? [y/n] " answer
        if [[ ${answer} = "y" ]] || [[ ${answer} = "Y" ]]; then
            ssh ${user}@${ip} "${tool_dir}/websync.sh -c2"
        else
            :;
        fi

    elif [ "$1" = "-a" ]; then
        for ((i = 2; i <= $#; i++)); do
            parse_add=$(eval echo \$$i)
            file_name=$(basename "${parse_add}")
            echo "add ${green}${file_name}${endcolor}"
            ssh ${user}@${ip} "${tool_dir}/websync.sh -a \"${file_name}\"" 
        done

    elif [ "$1" = "ls" ]; then
        ssh ${user}@${ip} "${tool_dir}/websync.sh -ls" 

    elif [ "$1" = "-expire" ]; then
        ssh ${user}@${ip} "${tool_dir}/websync.sh -expire" 

    else
        if [ ! -e "$1" ]; then
            echo "file not exists!" 1>&2
        elif [ -f "$1" ]; then
            realname=$(basename "$1")
            get_pub_name "${web}/${public}/${realname}" | pbcopy
            read -rp "Set Valid Time: " valid_time
            scp -r "${realname}" ${user}@${ip}:${file_dir}
            ssh ${user}@${ip} "${tool_dir}/websync.sh \"${realname}\" \"${valid_time}\""
            get_pub_name "${web}/${public}/${realname}"
        elif [ -d "$1" ]; then
            realname=$(basename "$1")
            get_pub_name "${web}/${public}/${realname}.zip" | pbcopy
            file_name=$(realpath "$1")
            pushd "$(dirname "${file_name}")" > /dev/null
            if [ ! -d ~/.tmp_zip ]; then
                mkdir -p ~/.tmp_zip
            fi
            if [ -e ~/.tmp_zip/"${realname}".zip ]; then
                rm ~/.tmp_zip/"${realname}".zip
            fi
            zip -r ~/.tmp_zip/"${realname}".zip "${realname}"
            popd > /dev/null
            read -rp "Set Valid Time: " valid_time
            scp -r ~/.tmp_zip/"${realname}".zip ${user}@${ip}:${file_dir}
            ssh ${user}@${ip} "${tool_dir}/websync.sh \"${realname}.zip\" \"${valid_time}\""
            get_pub_name "${web}/${public}/${realname}.zip"
            rm -r ~/.tmp_zip
        fi
    fi    
}

# offline download
function offline-download
{
    #ip="106.14.7.228"
    #base_dir="/root/02_Downloads"
    ip="108.61.247.112"
    base_dir="/root/01_Project/03_offline-download"
    user="root"

    torrent_dir="${base_dir}/00_torrent/"
    tool_dir="${base_dir}/02_tools/"
    download_torrent="$1"
    if [ ! ${download_torrent} = "-s" ]; then
        download_torrent_name=$(basename "${download_torrent}")
        simplified_torrent_name=$(echo "${download_torrent_name}" | strings | tr -d "\n" | tr -d " " | tr -d "\t")
    fi

    if [ ${download_torrent} = "-s" ]; then
        ssh ${user}@${ip} "${tool_dir}/show_status.sh ${tool_dir}"
    elif [ -f "${download_torrent}" ]; then
        scp -r "${download_torrent}" ${user}@${ip}:"${torrent_dir}/${simplified_torrent_name}"
        ssh -f -n ${user}@${ip} "${tool_dir}/start_download_torrent.sh ${torrent_dir}${simplified_torrent_name} &"
        rm "${download_torrent}"
    else
        ssh -f -n ${user}@${ip} "${tool_dir}/start_download_link.sh ${download_torrent} &"
    fi
}

# Decrypt
function decrypt
{
    decrypt_file="$1"
    decrypt_file_name=$(basename "${decrypt_file}")
    decrypt_file_path=$(dirname "${decrypt_file}")
    extension="${decrypt_file_name##*.}"
    decrypt_file_name_without_extension="${decrypt_file_name%.*}"
    decrypt_real_name="${decrypt_file_name_without_extension%.*}"

    if [[ ! ${extension} = "gpg" ]]; then
        echo "not exact file!"
    else
        gpg "${decrypt_file}"
        pushd "${decrypt_file_path}" > /dev/null
        unzip "${decrypt_file_name_without_extension}"
        popd >/dev/null
        rm "${decrypt_file_name_without_extension}"
        read -rp "delete download gpg file? [y/n] " answer
        if [[ ${answer} = "y" ]] || [[ ${answer} = "Y" ]]; then
            rm "${decrypt_file}"
        fi
        echo -e "\n${decrypt_file_path}/${decrypt_real_name}"
    fi
}

